
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.TargetDataLine;
import javax.swing.JColorChooser;
import javax.swing.JOptionPane;
import javax.swing.Timer;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author chris
 */
public class Window extends javax.swing.JFrame {
    Properties p = new Properties();
    /**
     * Creates new form Window
     */
    public Window() {
        initComponents();
        p.setBackground(p.currBackground);
        p.setStroke(p.currStoke);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jInternalFrame1 = new javax.swing.JInternalFrame();
        jToolBar2 = new javax.swing.JToolBar();
        jToolBar3 = new javax.swing.JToolBar();
        jToolBar1 = new javax.swing.JToolBar();
        BackgroundColorButton = new javax.swing.JButton();
        StrokeColorButton = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        Main = new javax.swing.JPanel();
        MenuBar = new javax.swing.JMenuBar();
        File = new javax.swing.JMenu();
        New = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        Open = new javax.swing.JMenuItem();
        Edit = new javax.swing.JMenu();
        Background = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JPopupMenu.Separator();
        Stroke = new javax.swing.JMenuItem();
        Images = new javax.swing.JMenu();
        Recording = new javax.swing.JMenu();
        Record = new javax.swing.JMenuItem();
        Play = new javax.swing.JMenuItem();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jInternalFrame1.setResizable(true);
        jInternalFrame1.setMaximumSize(new java.awt.Dimension(1500, 1500));
        try {
            jInternalFrame1.setSelected(true);
        } catch (java.beans.PropertyVetoException e1) {
            e1.printStackTrace();
        }
        jInternalFrame1.setVisible(true);

        jToolBar2.setBackground(new java.awt.Color(102, 102, 102));
        jToolBar2.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        jToolBar2.setRollover(true);

        jToolBar3.setBackground(new java.awt.Color(102, 102, 102));
        jToolBar3.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jToolBar3.setRollover(true);

        jToolBar1.setBackground(new java.awt.Color(153, 153, 153));
        jToolBar1.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jToolBar1.setRollover(true);

        BackgroundColorButton.setText("Background Color");
        BackgroundColorButton.setActionCommand("BackgroundColorButton");
        BackgroundColorButton.setFocusable(false);
        BackgroundColorButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        BackgroundColorButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        BackgroundColorButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                BackGroundButtonClicked(evt);
            }
        });
        jToolBar1.add(BackgroundColorButton);

        StrokeColorButton.setText("Stoke Color");
        StrokeColorButton.setActionCommand("StrokeColorButton");
        StrokeColorButton.setFocusable(false);
        StrokeColorButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        StrokeColorButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        StrokeColorButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                StrokeColorButtonClicked(evt);
            }
        });
        jToolBar1.add(StrokeColorButton);

        jButton1.setText("New Page");
        jButton1.setFocusable(false);
        jButton1.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton1.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NewPageActionPerformed(evt);
            }
        });
        jToolBar1.add(jButton1);

        Main.setBackground(new java.awt.Color(255, 255, 255));
        Main.setCursor(new java.awt.Cursor(java.awt.Cursor.CROSSHAIR_CURSOR));
        Main.setPreferredSize(new java.awt.Dimension(900, 936));
        boolean isMoving = false;
        boolean isClicked = false;
        Main.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                MainMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                MainMouseMoved(evt);
            }
        });
        Main.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                MainMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                MainMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                MainMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout MainLayout = new javax.swing.GroupLayout(Main);
        Main.setLayout(MainLayout);
        MainLayout.setHorizontalGroup(
            MainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 909, Short.MAX_VALUE)
        );
        MainLayout.setVerticalGroup(
            MainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        File.setText("File");

        New.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        New.setText("New");
        File.add(New);
        File.add(jSeparator1);

        Open.setText("Open");
        File.add(Open);

        MenuBar.add(File);

        Edit.setText("Edit");

        Background.setText("Background");
        Edit.add(Background);
        Edit.add(jSeparator2);

        Stroke.setText("Stroke ");
        Edit.add(Stroke);

        MenuBar.add(Edit);

        Images.setText("Images");
        MenuBar.add(Images);

        Recording.setText("Recording");

        Record.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_R, java.awt.event.InputEvent.CTRL_MASK));
        Record.setText("Record");
        Record.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RecordActionPerformed(evt);
            }
        });
        Recording.add(Record);

        Play.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.CTRL_MASK));
        Play.setText("Play");
        Play.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RecordingPlayActionPerformed(evt);
            }
        });
        Recording.add(Play);

        jMenuItem1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem1.setActionCommand("Stop Recording");
        jMenuItem1.setLabel("Stop Record");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                StopRecordingActionPerformed(evt);
            }
        });
        Recording.add(jMenuItem1);
        jMenuItem1.getAccessibleContext().setAccessibleName("StopRecord");

        jMenuItem2.setText("Read File");
        jMenuItem2.setActionCommand("ReadFile");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ReadFile(evt);
            }
        });
        Recording.add(jMenuItem2);

        MenuBar.add(Recording);

        jInternalFrame1.setJMenuBar(MenuBar);

        javax.swing.GroupLayout jInternalFrame1Layout = new javax.swing.GroupLayout(jInternalFrame1.getContentPane());
        jInternalFrame1.getContentPane().setLayout(jInternalFrame1Layout);
        jInternalFrame1Layout.setHorizontalGroup(
            jInternalFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBar2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(jInternalFrame1Layout.createSequentialGroup()
                .addComponent(jToolBar3, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Main, javax.swing.GroupLayout.PREFERRED_SIZE, 909, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 333, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(184, 184, 184))
        );
        jInternalFrame1Layout.setVerticalGroup(
            jInternalFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jInternalFrame1Layout.createSequentialGroup()
                .addComponent(jToolBar2, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jInternalFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(Main, javax.swing.GroupLayout.DEFAULT_SIZE, 594, Short.MAX_VALUE)
                    .addComponent(jToolBar3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, 594, Short.MAX_VALUE))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jInternalFrame1, javax.swing.GroupLayout.PREFERRED_SIZE, 1500, javax.swing.GroupLayout.PREFERRED_SIZE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jInternalFrame1, javax.swing.GroupLayout.DEFAULT_SIZE, 676, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void RecordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RecordActionPerformed
        int save = 0;
        int voice = 0;
        if(!p.seg.isEmpty())
           save =  JOptionPane.showConfirmDialog(null, "Do you want to save? All previous data will be lost."
                     ,"Record", JOptionPane.YES_NO_CANCEL_OPTION);
        if(save == 0){
            System.out.println("Clearing");
            p.clearAll();
        }
        voice =  JOptionPane.showConfirmDialog(null, "Do you want to Voice Record?"
                     ,"Record", JOptionPane.YES_NO_CANCEL_OPTION);
        if(voice == 0){
            p.isVoiceRecording = true;
            p.InitVoiceRecord();
            p.recording();
        }
    }//GEN-LAST:event_RecordActionPerformed

    private void MainMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_MainMouseDragged
            System.out.println("MouseDragged");
            Point point = new Point(evt.getX(), evt.getY());
            p.seg.add(point);
            System.out.println("Size A" + p.seg.size());
            p.setTimeDiff();
            p.draw(Main.getGraphics());
            System.out.printf("(%d,%d)\n", point.x, point.y);
    }//GEN-LAST:event_MainMouseDragged

    private void MainMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_MainMouseMoved
        p.setMoving(true);
    }//GEN-LAST:event_MainMouseMoved
      
    private void MainMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_MainMouseClicked
         System.out.println("Mouse clicked");
        //Point point = new Point(evt.getX(), evt.getY());
        //p.drawDot(Main.getGraphics(), point); 
    }//GEN-LAST:event_MainMouseClicked

    private void MainMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_MainMouseReleased
            System.out.println("Mouse Released");
            Point point = new Point(evt.getX(), evt.getY());
            p.drawDot(Main.getGraphics(), point); 
            p.setTimeBreak(p.timeDiff);
            p.segCounter+=1;
            System.out.println("SegCounter " +  p.segCounter);
    }//GEN-LAST:event_MainMouseReleased

    private void MainMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_MainMousePressed
        System.out.println("CurrTime: " + p.getCurrTime());
        p.setTimeDiff();
        System.out.println(p.getTimeDiff());
        
            System.out.println("Mouse Pressed");
            p.createSegment(p.segCounter);
            Point point = new Point(evt.getX(), evt.getY());
            p.seg.add(point);
            System.out.println("Size b " +p.seg.size());
    }//GEN-LAST:event_MainMousePressed

    private void BackGroundButtonClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_BackGroundButtonClicked
        JColorChooser BC = new JColorChooser();
        Color b = BC.showDialog(null, "Pick background color", Color.BLACK);
        p.setBackground(b);
    }//GEN-LAST:event_BackGroundButtonClicked

    private void StrokeColorButtonClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_StrokeColorButtonClicked
        JColorChooser BC = new JColorChooser();
        Color b = BC.showDialog(null, "Pick background color", Color.BLACK);
        p.setStroke(b);
    }//GEN-LAST:event_StrokeColorButtonClicked

    private void RecordingPlayActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RecordingPlayActionPerformed
        p.play();
    }//GEN-LAST:event_RecordingPlayActionPerformed

    private void StopRecordingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_StopRecordingActionPerformed
       p.stopRecording();
    }//GEN-LAST:event_StopRecordingActionPerformed

    private void NewPageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NewPageActionPerformed
        try {
            p.newPage();
        } catch (IOException ex) {
            Logger.getLogger(Window.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_NewPageActionPerformed

    private void ReadFile(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ReadFile
        try {
            p.text.check(1);
        } catch (IOException ex) {
            Logger.getLogger(Window.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_ReadFile

    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Window.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Window.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Window.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Window.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Window().setVisible(true);
            }
        });
    }
    class Properties {
        private Date time = new Date();
        private long currTime = setCurrTime(new Date());
        private long startTime = currTime;
        private long timeDiff;
        private Timings Ptimings= new Timings();
        private boolean isMoving = false;
        private boolean isClicked = false;
        private boolean canRecord = false;
        private Color currStoke = Color.BLACK;
        private Color currBackground = Color.WHITE;
        private int segCounter =0;
        private int strokeCounter = 0;
        private int pages = 1;
        private int backgroundCounter = 0;
        private VoiceRecording vr;
        private int timeBreakCounter = 0;
        private Text text = new Text();
        private ArrayList<Long> Times = new ArrayList<>();
        private ArrayList<Long> timeBreaks = new ArrayList<>();
        private ArrayList<Point> seg = new ArrayList<>();
        private ArrayList<ArrayList<Point>> segments = new ArrayList<>();
        private boolean isVoiceRecording = false;
        private Properties TempProperties;
        private boolean playing = false;
        private String [] data;
        public void setMoving(boolean move){
            System.out.println("Moving");
            this.isMoving = move;
        }
        public void setClicked(boolean clicked){
            System.out.println("Clicked");
            this.isMoving = clicked;
        }
        public void setStroke(Color c){
            this.currStoke = c;
        }
        public void setBackground(Color c){
            Main.setBackground(c);
            this.currBackground = c;
        }
        public long setCurrTime(Date d){
            return currTime = d.getTime();
        }
        public void setTimeBreak(Long time){
            this.timeBreaks.add(time);
//             for(int i = 0; i < timeBreaks.size(); i++)
//                System.out.println("Timesbreaks("+i+"): " + this.timeBreaks.get(i));
                
        }
        public void setTimeDiff(){
            Date d = new Date();
            timeDiff = d.getTime() - getCurrTime();
            setTimes(timeDiff);
            setCurrTime(new Date()); 
        }
        public void setTimes(Long time){
            this.Times.add(time);
        }
        
        public long getCurrTime(){
            return currTime;
        }
        public long getTimeDiff(){
            return timeDiff;
        }
        public boolean getVoiceRecording(){
            return isVoiceRecording;
        }
        public boolean getPlaying(){
            return playing;
        }
        public void draw(Graphics g){
            g.setColor(currStoke);
            System.out.println(this.isClicked);
            System.out.println(this.isMoving);
            System.out.println("Drawing");
            System.out.println("draw Seg Counter: " + segCounter);
            g.drawLine(segments.get(segCounter).get(seg.size()-2).x,
                       segments.get(segCounter).get(seg.size()-2).y, 
                       segments.get(segCounter).get(seg.size()-1).x,
                       segments.get(segCounter).get(seg.size()-1).y);
        }
        public void drawDot(Graphics g, Point point){
            g.setColor(currStoke); 
            g.fillRect(point.x, point.y, 1, 1);
            
        }
        public void createSegment(int index){
            ArrayList<Point> a = new ArrayList();
            seg = a;
            System.out.println("Size " + seg.size());
            segments.add(index, seg);
        }
        public void clearAll(){
            this.timeDiff= 0;
            this.seg.clear();
            this.segments.clear();
            this.segCounter=0;
            this.currStoke = Color.BLACK;
            this.setBackground(Color.WHITE);
            this.setCurrTime(new Date());
            this.Times.clear();
            this.timeBreakCounter = 0;
            this.timeBreaks.clear();
            this.clearScreen(Main.getGraphics());
        }
        public void record(){
            this.clearAll();
            this.canRecord = true;
        }
        public void InitVoiceRecord(){
            vr = new VoiceRecording();
        }
        public void newPage() throws IOException{
            text = new Text(pages);
            clearAll();
        }
        public void stopRecording(){
            isVoiceRecording = false;
             vr.finish();
        }
        public void recording(){
              // creates a new thread that waits for a specified
        Thread recorder = new Thread(new Runnable() {
            public void run(){
                 vr.start();
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException ex) {
                        ex.printStackTrace();
                    }
            }
        });
        recorder.start();
        }
        public void clearScreen(Graphics g){
            g.setColor(this.currBackground);
            g.fillRect(0,0, Main.getWidth(), Main.getHeight());
        }
        public void readData(String [] data, int page){
            int index = 0;
            int TempSegmentsIndex = -1;
            int TempSegIndex = -1;
            ArrayList<Long> TempTimes = new ArrayList<>();
            ArrayList<Long> TempTimeBreaks = new ArrayList<>();
            ArrayList<Point> TempSeg;
            ArrayList<ArrayList<Point>> TempSegments = new ArrayList<>();
            Color TempBackGround = Color.WHITE;
            Color TempStroke = Color.BLACK;
            String segmentDone = "-segmentDone-";
            String SegmentsDone = "-SegmentsDone-";
            String Segments = "-Segments-";
            String segs = "-segs-";
            String segsDone = "-segsDone-";
            String Times = "-Times-";
            String nextTime = "-nextTime-";
            String TimesDone = "-TimesDone-";
            String TimeDiff = "-TimeDiff-";
            String nextTimeDiff = "-nextTimeDiff-";
            String TimeDiffDone = "-TimeDiffDone-";
            String BackGround = "-BackGround-";
            String Stoke = "-Stoke-";
            String Finished = "-Finished-";
            while(index < data.length){
                System.out.println(data[index].trim());
                while(!data[index].trim().equals(SegmentsDone)){
                   System.out.println(data[index].trim());
                    if(data[index].trim().equals(Segments)){
                        index++;
                        TempSegmentsIndex++;
                        TempSeg = new ArrayList<>();
                        System.out.println(data[index].trim());
                        while(data[index].trim().equals(segs)){
                            index++;
                            TempSegIndex++;
                            String [] XY = data[index].trim().split(",");
                            Point point = new Point(Integer.parseInt(XY[0].trim()), Integer.parseInt(XY[1].trim()));
                            TempSeg.add(point);
                            index++;
                            System.out.println(data[index].trim());
                            if(data[index].trim().equals(segsDone)){
                               index++;
                               TempSegments.add(TempSeg);
                               TempSegIndex = 0;
                               if(data[index].trim().equals(segmentDone)){
                                   TempSegmentsIndex++;
                                   index++;
                               }
                            }
                        }
                    }
                }
                index++;
                //Where you left off reading times from file
                //System.out.println(data[index].trim());
                        if(data[index].trim().equals(Times)){
                             System.out.println("Comparar: " + data[index].trim());
                             index++;
                            while(!data[index].trim().equals("-TimesDone-")){
                                System.out.println(data[index].trim());
                                System.out.println("Time: " + data[index].trim());
                                TempTimes.add(Long.parseLong(data[index].trim()));
                                index++;
                                System.out.println("nextTime "+ data[index].trim());
                            if(data[index].trim().equals(nextTime))
                                index++;
                            }
                            
                        }
                        if(data[index].trim().equals(TimesDone)){
                            index++;
                            if(data[index].trim().equals(TimeDiff)){
                                while(!data[index].trim().equals("-TimeDiffDone-")){
                                    System.out.println("timediff "+data[index].trim());
                                    index++;
                                    System.out.println("Int: "+data[index].trim());
                                    TempTimeBreaks.add(Long.parseLong(data[index].trim()));
                                    index++;
                                    System.out.println("nextTime" + data[index].trim());
                                    if(data[index].trim().equals(nextTimeDiff)){
                                        if(data[index+1].trim().equals(TimeDiffDone)){
                                            System.out.println("done");
                                            index++;
                                        }
                                }
                                    if(data[index].trim().equals(TimeDiffDone)){
                                        System.out.println("Stay");
                            }
                        }
                            }
                        if(data[index].trim().equals(TimeDiffDone))
                                            index++;
                                    }
                        if(data[index].trim().equals(BackGround)){
                            index++;
                            String [] color = data[index].trim().split(",");
                            float [] c = Color.RGBtoHSB(Integer.parseInt(color[0]), Integer.parseInt(color[1]), Integer.parseInt(color[2]),null);
                   
                            TempBackGround = Color.getHSBColor(c[0], c[1], c[2]);
                            index++;
                        } 
                        if(data[index].trim().equals(Stoke)){
                            index++;
                            String [] color = data[index].trim().split(",");
                            float [] c = Color.RGBtoHSB(Integer.parseInt(color[0]), Integer.parseInt(color[1]), Integer.parseInt(color[2]),null);
                            TempStroke = Color.getHSBColor(c[0], c[1], c[2]);
                            index++;
                        } 
                        if(data[index].trim().equals(Finished)){
                            index++;
                        }
            }
            System.out.println("Reading Complete....");
            TempProperties = new Properties();
            TempProperties.currStoke = TempStroke;
            TempProperties.currBackground = TempBackGround;
            TempProperties.segments = TempSegments;
            System.out.println(TempSegments.get(0).get(0).x + "," +TempSegments.get(0).get(0).y);
            TempProperties.Times = TempTimes;
            System.out.println("Temp times: "+TempTimes.get(0));
            TempProperties.timeBreaks = TempTimeBreaks;
            System.out.println("Temp: " + TempProperties.currBackground);
            TempProperties.play(page);
        }
        public void play(){
            clearScreen(Main.getGraphics());
            System.out.println("Playing....");
            Timers timer = new Timers();
            timer.drawTimer.start();
            p.clearScreen(Main.getGraphics()); 
        }
        public void play(int pages){
            clearScreen(Main.getGraphics());
            System.out.println("Playing....");
            Timers timer = new Timers();
            timer.currpage = pages;
            timer.drawTimer.start();
            p.clearScreen(Main.getGraphics()); 
        }
        class Timers{
            Replay replay= new Replay(this,Ptimings);
            Timer drawTimer = new Timer(1,replay);
            Timer strokeTimer = new Timer(1,null);
            Timer backgroundTimer = new Timer(1,null);
            long drawCounter = 0;
            long strokeCounter = 0;
            long backgroundCounter = 0;
            int currpage = -1;
            long getDrawCounter(){
                System.out.println("Drawcounter: " + drawCounter);
                return drawCounter;
            }
            long getStrokeCounter(){
                return strokeCounter;
            }
             long getBackgroundCounter(){
                return backgroundCounter;
            }
        }
        class Timings{
            private long startTime = 0;
            private long backgroundCT = 0;
            private long strokeCT = 0;
            private ArrayList<Long> strokeTimes = new ArrayList<>();
            private ArrayList<Long> backgroundTimes= new ArrayList<>();
            public void setStartTime(long s){
                this.startTime = s;
            }
            
            public long setCurrTime(Date d){
            return d.getTime();
        }
            
            public void setTimeDiff(long currtime, ArrayList<Long> list){ 
                Date d = new Date();
                long ct = d.getTime();
                long timediff = d.getTime() - currTime;
                list.add(timediff);
                currtime = ct;
            } 
        }
        public class VoiceRecording{// record duration, in milliseconds
            static final long RECORD_TIME = 6000; // 1 minute
            // path of the wav file
            File wavFile = new File("RecordAudio.wav");
            // format of audio file
            AudioFileFormat.Type fileType = AudioFileFormat.Type.WAVE;
    
            // the line from which audio data is captured
            TargetDataLine line;

            AudioFormat getAudioFormat() {
                float sampleRate = 8000;
                int sampleSizeInBits = 16;
                int channels = 2;
                boolean signed = true;
                boolean bigEndian = true;
                AudioFormat format = new AudioFormat(sampleRate, sampleSizeInBits,channels, signed, bigEndian);
                return format;
            }
    /**
     * Captures the sound and record into a WAV file
     */
    void start() {
        try {
            AudioFormat format = getAudioFormat();
            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);
            // checks if system supports the data line
            if (!AudioSystem.isLineSupported(info)) {
                System.out.println("Line not supported");
                System.exit(0);
            }
            line = (TargetDataLine) AudioSystem.getLine(info);
            line.open(format);
            line.start(); // start capturingSystem.out.println("Start capturing..."); 
            AudioInputStream ais = new AudioInputStream(line);
            System.out.println("Start recording...");
            
            // start recording
            AudioSystem.write(ais, fileType, wavFile);
        } catch (LineUnavailableException ex) {
            ex.printStackTrace();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
    /**
     * Closes the target data line to finish capturing and recording
     */
            void finish() {
                line.stop();
                line.close();
                System.out.println("Finished");
            }
        }
        class Replay implements ActionListener{
            long t = 0;
            int Bseg = 0;
            int Sseg = 0 ;
            int times = 0;
            int tbreaks = 0;
            int sc = 1;
            int bc = 1;
            int currpage = -1;
            String file = "";
            Graphics g = Main.getGraphics();
            Timers timers;
            Timings replayTimings;
            Replay(Timers t, Timings tm){
                timers= t;
                if(t == null)
                    System.out.println("t is null");
                replayTimings = tm;
            }
            public String getFile(){
                return file;
            }
            @Override
            public void actionPerformed(ActionEvent ae) {
                Main.setBackground(currBackground);
                System.out.print("Color: " + currBackground);
                g.setColor(currStoke);
                 if(Bseg < segments.size()){
                   System.out.println("Bseg: " + Bseg +" size: " + segments.get(Bseg).size());
                   if(Sseg+1 < (segments.get(Bseg).size())){
                       System.out.println("P times " + Times.get(this.times));
                        if(timers.getDrawCounter() == Times.get(this.times)){
                            System.out.println("P times " + Times.get(this.times));
                            g.drawLine(segments.get(Bseg).get(Sseg).x,
                               segments.get(Bseg).get(Sseg).y,
                               segments.get(Bseg).get(Sseg+1).x, 
                               segments.get(Bseg).get(Sseg+1).y);
                            timers.drawTimer.restart();
                            timers.drawCounter=0;
                            Sseg+=1;
                            this.times++;
                    }
                }
               else{
                   Bseg+=1;
                   Sseg = 0;
                   timers.drawCounter=0;
                 }
                }
                if(Bseg == segments.size()){
                    this.Bseg = 0;
                    this.Sseg = 0;
                    this.t = 0;
                    this.timers.drawTimer.stop();
                    playing = false;
                    if(timers.currpage != -1){
                        try {
                            text.check(timers.currpage+1);
                        } catch (IOException ex) {
                            Logger.getLogger(Window.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                }
            this.timers.drawCounter++;
            }
            
        }
        public class Text {
            DataOutputStream dos;
            String [] file;
            Reading reading;
            boolean canPlay = true;
               public void check (int fileName) throws FileNotFoundException, IOException{
                    if(new File(Integer.toString(fileName)).exists()){
                        System.out.println("File exist");
                        reading = new Reading(new FileInputStream(Integer.toString(fileName)));
                        System.out.println("Reading...........................");
                        reading.read();
                        file = reading.getText().split(" ");
                        System.out.println(file[0]);
                        reading.close();
                        readData(file, fileName);
                    }
                    else{
                      System.out.println("File Doesn't exist");
                    } 
                }
            
            public Text(){    
            }
            public Text(int num) throws FileNotFoundException, IOException{
                dos = new DataOutputStream(new FileOutputStream(Integer.toString(pages)));
                int segTempCount =0;
                int segmentsTempCount =0;
                while(segmentsTempCount < segments.size()){
                    dos.writeUTF("-Segments- ");
                    System.out.println("Segments");
                    while(segTempCount < segments.get(segmentsTempCount).size()){
                        dos.writeUTF("-segs- ");
                        System.out.println("segs");
                        String points = segments.get(segmentsTempCount).get(segTempCount).x + ","+segments.get(segmentsTempCount).get(segTempCount).y + " ";
                        dos.writeUTF(points);
                        System.out.println(points);
                        segTempCount++;
                    }
                    System.out.println("segsDone");
                    dos.writeUTF("-segsDone- ");
                    segTempCount = 0;
                    segmentsTempCount++;
                    dos.writeUTF("-segmentDone- ");
                }
                dos.writeUTF("-SegmentsDone- ");
                dos.writeUTF("-Times- ");
                int timesIndex = 0;
                while(timesIndex <Times.size()){
                    dos.writeUTF(Long.toString(Times.get(timesIndex))+ " ");
                    dos.writeUTF("-nextTime- ");
                    timesIndex++;
                }
                dos.writeUTF("-TimesDone- ");
                timesIndex = 0;
                dos.writeUTF("-TimeDiff- ");
                while(timesIndex < timeBreaks.size()){
                    dos.writeUTF(Long.toString(timeBreaks.get(timesIndex))+ " ");
                    dos.writeUTF("-nextTimeDiff- ");
                    timesIndex++;
                }
                dos.writeUTF("-TimeDiffDone- ");
                dos.writeUTF("-BackGround- ");
                dos.writeUTF(currBackground.getRed()+ ","+currBackground.getGreen()+","+currBackground.getBlue()+ " ");
                dos.writeUTF("-Stoke- ");
                dos.writeUTF(currStoke.getRed()+ ","+currStoke.getGreen()+","+currStoke.getBlue()+ " ");
                dos.writeUTF("-Finished- ");
                dos.flush();
                dos.close();
                Reading reading = new Reading(new FileInputStream(Integer.toString(pages)));
                
                pages+=1;
            }
            public class Reading extends FilterInputStream {
            private String message = "";
            public Reading(InputStream in) throws IOException{
                super(in);
        }
            @Override
        public int read() throws IOException{
            String temp = "";
            int value;
            String FirstLetter = "";
            int counter = 0;
            while(((value = in.read()) != -1)){
                if(counter == 0)
                    in.skip(1);
                message += (char)value;
                counter++;
            }
            temp += message;
            message = temp;

        return 0;

        }
        public String getText(){
            return message;
        }
            }
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem Background;
    private javax.swing.JButton BackgroundColorButton;
    private javax.swing.JMenu Edit;
    private javax.swing.JMenu File;
    private javax.swing.JMenu Images;
    private javax.swing.JPanel Main;
    private javax.swing.JMenuBar MenuBar;
    private javax.swing.JMenuItem New;
    private javax.swing.JMenuItem Open;
    private javax.swing.JMenuItem Play;
    private javax.swing.JMenuItem Record;
    private javax.swing.JMenu Recording;
    private javax.swing.JMenuItem Stroke;
    private javax.swing.JButton StrokeColorButton;
    private javax.swing.JButton jButton1;
    private javax.swing.JInternalFrame jInternalFrame1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JPopupMenu.Separator jSeparator2;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JToolBar jToolBar2;
    private javax.swing.JToolBar jToolBar3;
    // End of variables declaration//GEN-END:variables
}
